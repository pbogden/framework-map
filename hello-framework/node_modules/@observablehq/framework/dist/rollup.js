import { extname } from "node:path/posix";
import { nodeResolve } from "@rollup/plugin-node-resolve";
import { simple } from "acorn-walk";
import { build } from "esbuild";
import { rollup } from "rollup";
import esbuild from "rollup-plugin-esbuild";
import { getStylePath } from "./files.js";
import { getStringLiteralValue, isStringLiteral } from "./javascript/source.js";
import { resolveNpmImport } from "./npm.js";
import { getObservableUiOrigin } from "./observableApiClient.js";
import { isPathImport, relativePath } from "./path.js";
import { Sourcemap } from "./sourcemap.js";
import { THEMES, renderTheme } from "./theme.js";
const STYLE_MODULES = {
  "observablehq:default.css": getStylePath("default.css"),
  ...Object.fromEntries(THEMES.map(({ name, path }) => [`observablehq:theme-${name}.css`, path]))
};
const BUNDLED_MODULES = [
  "@observablehq/inputs",
  // observablehq:stdlib/inputs.js
  "@observablehq/inspector",
  // observablehq:runtime.js
  "@observablehq/runtime",
  // observablehq:runtime.js
  "isoformat",
  // observablehq:runtime.js
  "minisearch"
  // observablehq:search.js
];
function rewriteInputsNamespace(code) {
  return code.replace(/\b__ns__\b/g, "inputs-3a86ea");
}
async function bundleStyles({
  minify = false,
  path,
  theme
}) {
  const result = await build({
    bundle: true,
    ...path ? { entryPoints: [path] } : { stdin: { contents: renderTheme(theme), loader: "css" } },
    write: false,
    minify,
    alias: STYLE_MODULES
  });
  const text = result.outputFiles[0].text;
  return rewriteInputsNamespace(text);
}
async function rollupClient(input, root, path, { define, keepNames, minify } = {}) {
  const bundle = await rollup({
    input,
    external: [/^https:/],
    plugins: [
      nodeResolve({ resolveOnly: BUNDLED_MODULES }),
      importResolve(input, root, path),
      esbuild({
        format: "esm",
        platform: "browser",
        target: ["es2022", "chrome96", "firefox96", "safari16", "node18"],
        exclude: [],
        // donâ€™t exclude node_modules
        keepNames,
        minify,
        define: {
          "global.__minisearch": '"./minisearch.json"',
          "process.env.OBSERVABLE_ORIGIN": JSON.stringify(String(getObservableUiOrigin()).replace(/\/$/, "")),
          ...define
        }
      }),
      importMetaResolve(root, path)
    ],
    onwarn(message, warn) {
      if (message.code === "CIRCULAR_DEPENDENCY")
        return;
      warn(message);
    }
  });
  try {
    const output = await bundle.generate({ format: "es" });
    let code = output.output.find((o) => o.type === "chunk").code;
    code = rewriteTypeScriptImports(code);
    code = rewriteInputsNamespace(code);
    return code;
  } finally {
    await bundle.close();
  }
}
function rewriteTypeScriptImports(code) {
  return code.replace(/(?<=\bimport\(([`'"])[\w./]+)\.ts(?=\1\))/g, ".js");
}
function importResolve(input, root, path) {
  async function resolve(specifier) {
    return typeof specifier !== "string" || specifier === input ? null : specifier.startsWith("observablehq:") ? { id: relativePath(path, `/_observablehq/${specifier.slice("observablehq:".length)}${extname(specifier) ? "" : ".js"}`), external: true } : specifier === "npm:@observablehq/runtime" ? { id: relativePath(path, "/_observablehq/runtime.js"), external: true } : specifier === "npm:@observablehq/stdlib" || specifier === "@observablehq/stdlib" ? { id: relativePath(path, "/_observablehq/stdlib.js"), external: true } : specifier === "npm:@observablehq/dot" ? { id: relativePath(path, "/_observablehq/stdlib/dot.js"), external: true } : specifier === "npm:@observablehq/duckdb" ? { id: relativePath(path, "/_observablehq/stdlib/duckdb.js"), external: true } : specifier === "npm:@observablehq/inputs" ? { id: relativePath(path, "/_observablehq/stdlib/inputs.js"), external: true } : specifier === "npm:@observablehq/mermaid" ? { id: relativePath(path, "/_observablehq/stdlib/mermaid.js"), external: true } : specifier === "npm:@observablehq/tex" ? { id: relativePath(path, "/_observablehq/stdlib/tex.js"), external: true } : specifier === "npm:@observablehq/sqlite" ? { id: relativePath(path, "/_observablehq/stdlib/sqlite.js"), external: true } : specifier === "npm:@observablehq/xlsx" ? { id: relativePath(path, "/_observablehq/stdlib/xlsx.js"), external: true } : specifier === "npm:@observablehq/zip" ? { id: relativePath(path, "/_observablehq/stdlib/zip.js"), external: true } : specifier.startsWith("npm:") ? { id: relativePath(path, await resolveNpmImport(root, specifier.slice("npm:".length))), external: true } : !/^[a-z]:\\/i.test(specifier) && !isPathImport(specifier) && !BUNDLED_MODULES.includes(specifier) ? { id: relativePath(path, await resolveNpmImport(root, specifier)), external: true } : null;
  }
  return {
    name: "resolve-import",
    resolveId: resolve,
    resolveDynamicImport: resolve
  };
}
function importMetaResolve(root, path) {
  return {
    name: "resolve-import-meta-resolve",
    async transform(code) {
      const program = this.parse(code);
      const resolves = [];
      simple(program, {
        CallExpression(node) {
          if (node.callee.type === "MemberExpression" && node.callee.object.type === "MetaProperty" && node.callee.property.type === "Identifier" && node.callee.property.name === "resolve" && node.arguments.length === 1 && isStringLiteral(node.arguments[0])) {
            resolves.push(node);
          }
        }
      });
      if (!resolves.length)
        return null;
      const output = new Sourcemap(code);
      for (const node of resolves) {
        const source = node.arguments[0];
        const specifier = getStringLiteralValue(source);
        if (specifier.startsWith("npm:")) {
          const resolution = relativePath(path, await resolveNpmImport(root, specifier.slice("npm:".length)));
          output.replaceLeft(source.start, source.end, JSON.stringify(resolution));
        }
      }
      return { code: String(output) };
    }
  };
}
export {
  bundleStyles,
  rollupClient
};
