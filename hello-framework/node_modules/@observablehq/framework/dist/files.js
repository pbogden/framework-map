import { existsSync, readdirSync, statSync } from "node:fs";
import { mkdir, stat } from "node:fs/promises";
import op from "node:path";
import { extname, join, normalize, relative, sep } from "node:path/posix";
import { cwd } from "node:process";
import { fileURLToPath } from "node:url";
import { isEnoent } from "./error.js";
function toOsPath(path) {
  return path.split(sep).join(op.sep);
}
function fromOsPath(path) {
  return path.split(op.sep).join(sep);
}
function getClientPath(entry) {
  const path = fromOsPath(op.relative(cwd(), op.join(fileURLToPath(import.meta.url), "..", "client", entry)));
  if (path.endsWith(".js") && !existsSync(path)) {
    const tspath = path.slice(0, -".js".length) + ".ts";
    if (existsSync(tspath))
      return tspath;
  }
  return path;
}
function getStylePath(entry) {
  return fromOsPath(op.relative(cwd(), op.join(fileURLToPath(import.meta.url), "..", "style", entry)));
}
function* visitMarkdownFiles(root) {
  for (const file of visitFiles(root)) {
    if (extname(file) !== ".md")
      continue;
    yield file;
  }
}
function* visitFiles(root) {
  const visited = /* @__PURE__ */ new Set();
  const queue = [root = normalize(root)];
  for (const path of queue) {
    const status = statSync(path);
    if (status.isDirectory()) {
      if (visited.has(status.ino))
        continue;
      visited.add(status.ino);
      for (const entry of readdirSync(path)) {
        if (entry === ".observablehq")
          continue;
        queue.push(join(path, entry));
      }
    } else {
      yield relative(root, path);
    }
  }
}
async function maybeStat(path) {
  try {
    return await stat(path);
  } catch (error) {
    if (!isEnoent(error))
      throw error;
  }
}
async function prepareOutput(outputPath) {
  const outputDir = op.dirname(outputPath);
  if (outputDir === ".")
    return;
  await mkdir(outputDir, { recursive: true });
}
export {
  fromOsPath,
  getClientPath,
  getStylePath,
  maybeStat,
  prepareOutput,
  toOsPath,
  visitFiles,
  visitMarkdownFiles
};
