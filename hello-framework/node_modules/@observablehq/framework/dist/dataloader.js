import { createHash } from "node:crypto";
import { createReadStream, existsSync, statSync } from "node:fs";
import { open, readFile, rename, unlink } from "node:fs/promises";
import { dirname, extname, join, relative } from "node:path/posix";
import { createGunzip } from "node:zlib";
import { spawn } from "cross-spawn";
import JSZip from "jszip";
import { extract } from "tar-stream";
import { maybeStat, prepareOutput } from "./files.js";
import { FileWatchers } from "./fileWatchers.js";
import { formatByteSize } from "./format.js";
import { getFileInfo } from "./javascript/module.js";
import { cyan, faint, green, red, yellow } from "./tty.js";
const runningCommands = /* @__PURE__ */ new Map();
const defaultInterpreters = {
  ".js": ["node", "--no-warnings=ExperimentalWarning"],
  ".ts": ["tsx"],
  ".py": ["python3"],
  ".r": ["Rscript"],
  ".R": ["Rscript"],
  ".rs": ["rust-script"],
  ".go": ["go", "run"],
  ".java": ["java"],
  ".jl": ["julia"],
  ".php": ["php"],
  ".sh": ["sh"],
  ".exe": []
};
const defaultEffects = {
  logger: console,
  output: process.stdout
};
class LoaderResolver {
  root;
  interpreters;
  constructor({ root, interpreters }) {
    this.root = root;
    this.interpreters = new Map(
      Object.entries({ ...defaultInterpreters, ...interpreters }).filter(
        (entry) => entry[1] != null
      )
    );
  }
  /**
   * Finds the loader for the specified target path, relative to the specified
   * source root, if it exists. If there is no such loader, returns undefined.
   * For files within archives, we find the first parent folder that exists, but
   * abort if we find a matching folder or reach the source root; for example,
   * if src/data exists, we won’t look for a src/data.zip.
   */
  find(targetPath, { useStale = false } = {}) {
    const exact = this.findExact(targetPath, { useStale });
    if (exact)
      return exact;
    let dir = dirname(targetPath);
    for (let parent; true; dir = parent) {
      parent = dirname(dir);
      if (parent === dir)
        return;
      if (existsSync(join(this.root, dir)))
        return;
      if (existsSync(join(this.root, parent)))
        break;
    }
    for (const [ext, Extractor] of extractors) {
      const archive = dir + ext;
      if (existsSync(join(this.root, archive))) {
        return new Extractor({
          preload: async () => archive,
          inflatePath: targetPath.slice(archive.length - ext.length + 1),
          path: join(this.root, archive),
          root: this.root,
          targetPath,
          useStale
        });
      }
      const archiveLoader = this.findExact(archive, { useStale });
      if (archiveLoader) {
        return new Extractor({
          preload: async (options) => archiveLoader.load(options),
          inflatePath: targetPath.slice(archive.length - ext.length + 1),
          path: archiveLoader.path,
          root: this.root,
          targetPath,
          useStale
        });
      }
    }
  }
  findExact(targetPath, { useStale }) {
    for (const [ext, [command, ...args]] of this.interpreters) {
      if (!existsSync(join(this.root, targetPath + ext)))
        continue;
      if (extname(targetPath) === "") {
        console.warn(`invalid data loader path: ${targetPath + ext}`);
        return;
      }
      const path = join(this.root, targetPath + ext);
      return new CommandLoader({
        command: command ?? path,
        args: command == null ? args : [...args, path],
        path,
        root: this.root,
        targetPath,
        useStale
      });
    }
  }
  getWatchPath(path) {
    const exactPath = join(this.root, path);
    if (existsSync(exactPath))
      return exactPath;
    if (exactPath.endsWith(".js")) {
      const jsxPath = exactPath + "x";
      if (existsSync(jsxPath))
        return jsxPath;
    }
    return this.find(path)?.path;
  }
  watchFiles(path, watchPaths, callback) {
    return FileWatchers.of(this, path, watchPaths, callback);
  }
  /**
   * Returns the path to the backing file during preview, which is the source
   * file for the associated data loader if the file is generated by a loader.
   */
  getSourceFilePath(name) {
    let path = name;
    if (!existsSync(join(this.root, path))) {
      const loader = this.find(path);
      if (loader)
        path = relative(this.root, loader.path);
    }
    return path;
  }
  /**
   * Returns the path to the backing file during build, which is the cached
   * output file if the file is generated by a loader.
   */
  getOutputFilePath(name) {
    let path = name;
    if (!existsSync(join(this.root, path))) {
      const loader = this.find(path);
      if (loader)
        path = join(".observablehq", "cache", name);
    }
    return path;
  }
  /**
   * Returns the hash of the file with the given name within the source root, or
   * if the name refers to a file generated by a data loader, the hash of the
   * corresponding data loader source and its modification time. The latter
   * ensures that if the data loader is “touched” (even without changing its
   * contents) that the data loader will be re-run.
   */
  getSourceFileHash(name) {
    const path = this.getSourceFilePath(name);
    const info = getFileInfo(this.root, path);
    if (!info)
      return createHash("sha256").digest("hex");
    const { hash } = info;
    return path === name ? hash : createHash("sha256").update(hash).update(String(info.mtimeMs)).digest("hex");
  }
  getSourceLastModified(name) {
    const entry = getFileInfo(this.root, this.getSourceFilePath(name));
    return entry && Math.floor(entry.mtimeMs);
  }
  getOutputLastModified(name) {
    const entry = getFileInfo(this.root, this.getOutputFilePath(name));
    return entry && Math.floor(entry.mtimeMs);
  }
  resolveFilePath(path) {
    return `/${join("_file", path)}?sha=${this.getSourceFileHash(path)}`;
  }
}
class Loader {
  /**
   * The source root relative to the current working directory, such as src.
   */
  root;
  /**
   * The path to the loader script or executable relative to the current working
   * directory. This is exposed so that clients can check which file to watch to
   * see if the loader is edited (and in which case it needs to be re-run).
   */
  path;
  /**
   * The path to the loader script’s output relative to the destination root.
   * This is where the loader’s output is served, but the loader generates the
   * file in the .observablehq/cache directory within the source root.
   */
  targetPath;
  /**
   * Should the loader use a stale cache. true when building.
   */
  useStale;
  constructor({ root, path, targetPath, useStale }) {
    this.root = root;
    this.path = path;
    this.targetPath = targetPath;
    this.useStale = useStale;
  }
  /**
   * Runs this loader, returning the path to the generated output file relative
   * to the source root; this is within the .observablehq/cache folder within
   * the source root.
   */
  async load(effects = defaultEffects) {
    const key = join(this.root, this.targetPath);
    let command = runningCommands.get(key);
    if (!command) {
      command = (async () => {
        const outputPath = join(".observablehq", "cache", this.targetPath);
        const cachePath = join(this.root, outputPath);
        const loaderStat = await maybeStat(this.path);
        const cacheStat = await maybeStat(cachePath);
        if (!cacheStat)
          effects.output.write(faint("[missing] "));
        else if (cacheStat.mtimeMs < loaderStat.mtimeMs) {
          if (this.useStale)
            return effects.output.write(faint("[using stale] ")), outputPath;
          else
            effects.output.write(faint("[stale] "));
        } else
          return effects.output.write(faint("[fresh] ")), outputPath;
        const tempPath = join(this.root, ".observablehq", "cache", `${this.targetPath}.${process.pid}`);
        const errorPath = tempPath + ".err";
        const errorStat = await maybeStat(errorPath);
        if (errorStat) {
          if (errorStat.mtimeMs > loaderStat.mtimeMs && errorStat.mtimeMs > -1e3 + Date.now())
            throw new Error("loader skipped due to recent error");
          else
            await unlink(errorPath).catch(() => {
            });
        }
        await prepareOutput(tempPath);
        await prepareOutput(cachePath);
        const tempFd = await open(tempPath, "w");
        try {
          await this.exec(tempFd.createWriteStream({ highWaterMark: 1024 * 1024 }), effects);
          await rename(tempPath, cachePath);
        } catch (error) {
          await rename(tempPath, errorPath);
          throw error;
        } finally {
          await tempFd.close();
        }
        return outputPath;
      })();
      command.finally(() => runningCommands.delete(key)).catch(() => {
      });
      runningCommands.set(key, command);
    }
    effects.output.write(`${cyan("load")} ${this.path} ${faint("\u2192")} `);
    const start = performance.now();
    command.then(
      (path) => {
        const { size } = statSync(join(this.root, path));
        effects.logger.log(
          `${green("success")} ${size ? cyan(formatByteSize(size)) : yellow("empty output")} ${faint(
            `in ${formatElapsed(start)}`
          )}`
        );
      },
      (error) => {
        effects.logger.log(`${red("error")} ${faint(`in ${formatElapsed(start)}:`)} ${red(error.message)}`);
      }
    );
    return command;
  }
}
class CommandLoader extends Loader {
  /**
   * The command to run, such as "node" for a JavaScript loader, "tsx" for
   * TypeScript, and "sh" for a shell script. "noop" when we only need to
   * inflate a file from a static archive.
   */
  command;
  /**
   * Args to pass to the command; currently this is a single argument of the
   * path to the loader script relative to the current working directory. (TODO
   * Support passing additional arguments to loaders.)
   */
  args;
  constructor({ command, args, ...options }) {
    super(options);
    this.command = command;
    this.args = args;
  }
  async exec(output) {
    const subprocess = spawn(this.command, this.args, { windowsHide: true, stdio: ["ignore", output, "inherit"] });
    const code = await new Promise((resolve, reject) => {
      subprocess.on("error", reject);
      subprocess.on("close", resolve);
    });
    if (code !== 0) {
      throw new Error(`loader exited with code ${code}`);
    }
  }
}
class ZipExtractor extends Loader {
  preload;
  inflatePath;
  constructor({ preload, inflatePath, ...options }) {
    super(options);
    this.preload = preload;
    this.inflatePath = inflatePath;
  }
  async exec(output, effects) {
    const archivePath = join(this.root, await this.preload(effects));
    const file = (await JSZip.loadAsync(await readFile(archivePath))).file(this.inflatePath);
    if (!file)
      throw Object.assign(new Error("file not found"), { code: "ENOENT" });
    const pipe = file.nodeStream().pipe(output);
    await new Promise((resolve, reject) => pipe.on("error", reject).on("finish", resolve));
  }
}
class TarExtractor extends Loader {
  preload;
  inflatePath;
  gunzip;
  constructor({ preload, inflatePath, gunzip = false, ...options }) {
    super(options);
    this.preload = preload;
    this.inflatePath = inflatePath;
    this.gunzip = gunzip;
  }
  async exec(output, effects) {
    const archivePath = join(this.root, await this.preload(effects));
    const tar = extract();
    const input = createReadStream(archivePath);
    (this.gunzip ? input.pipe(createGunzip()) : input).pipe(tar);
    for await (const entry of tar) {
      if (entry.header.name === this.inflatePath) {
        const pipe = entry.pipe(output);
        await new Promise((resolve, reject) => pipe.on("error", reject).on("finish", resolve));
        return;
      } else {
        entry.resume();
      }
    }
    throw Object.assign(new Error("file not found"), { code: "ENOENT" });
  }
}
class TarGzExtractor extends TarExtractor {
  constructor(options) {
    super({ ...options, gunzip: true });
  }
}
const extractors = [
  [".zip", ZipExtractor],
  [".tar", TarExtractor],
  [".tar.gz", TarGzExtractor],
  [".tgz", TarGzExtractor]
];
function formatElapsed(start) {
  const elapsed = performance.now() - start;
  return `${Math.floor(elapsed)}ms`;
}
export {
  Loader,
  LoaderResolver,
  defaultInterpreters
};
